import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import { findCompositeShapesHint } from '../src/logic/techniques/compositeShapes';
import { findCompositeShape, computeMinStars, computeMaxStars } from '../src/logic/helpers';
import type { PuzzleState, PuzzleDef, CellState, Coords } from '../src/types/puzzle';

// Helper to create a puzzle state
function createPuzzleState(size: number, starsPerUnit: number, regions: number[][], cells: CellState[][]): PuzzleState {
  const def: PuzzleDef = { size, starsPerUnit, regions };
  return { def, cells };
}

// Arbitrary generator for valid cell coordinates
const coordsArb = fc.record({
  row: fc.integer({ min: 0, max: 9 }),
  col: fc.integer({ min: 0, max: 9 }),
});

// Generator for a list of unique coordinates
const uniqueCoordsArb = fc.array(coordsArb, { minLength: 1, maxLength: 30 }).map((coords) => {
  const seen = new Set<string>();
  const unique: Coords[] = [];
  for (const coord of coords) {
    const key = `${coord.row},${coord.col}`;
    if (!seen.has(key)) {
      seen.add(key);
      unique.push(coord);
    }
  }
  return unique;
});

describe('Composite Shapes - Property Tests', () => {
  /**
   * Property 17: Composite shapes compute valid bounds
   * Validates: Requirements 10.1
   * 
   * For any composite shape formed from multiple regions or partial regions,
   * the computed minimum star count should be less than or equal to the
   * maximum star count.
   */
  it('Property 17: minimum stars never exceeds maximum stars for composite shapes', () => {
    fc.assert(
      fc.property(uniqueCoordsArb, (cells) => {
        // Create a simple puzzle state with empty cells
        const size = 10;
        const starsPerUnit = 2;
        const regions: number[][] = [];
        const cellStates: CellState[][] = [];
        
        // Create a region layout
        for (let r = 0; r < size; r++) {
          const regionRow: number[] = [];
          const cellRow: CellState[] = [];
          for (let c = 0; c < size; c++) {
            // Create regions in a 2x5 grid pattern
            regionRow.push(Math.floor(r / 2) * 5 + Math.floor(c / 2) + 1);
            cellRow.push('empty');
          }
          regions.push(regionRow);
          cellStates.push(cellRow);
        }
        
        const state = createPuzzleState(size, starsPerUnit, regions, cellStates);
        
        // Create a composite shape from the given cells
        const shape = findCompositeShape(state, cells);
        
        // Property: min should never exceed max
        expect(shape.minStars).toBeLessThanOrEqual(shape.maxStars);
      }),
      { numRuns: 100 }
    );
  });

  /**
   * Property 17 (variant): Bounds remain valid with stars placed
   */
  it('Property 17: bounds remain valid when stars are placed in the shape', () => {
    fc.assert(
      fc.property(
        uniqueCoordsArb,
        fc.integer({ min: 0, max: 5 }),
        (cells, numStars) => {
          // Create a puzzle state
          const size = 10;
          const starsPerUnit = 2;
          const regions: number[][] = [];
          const cellStates: CellState[][] = [];
          
          for (let r = 0; r < size; r++) {
            const regionRow: number[] = [];
            const cellRow: CellState[] = [];
            for (let c = 0; c < size; c++) {
              regionRow.push(Math.floor(r / 2) * 5 + Math.floor(c / 2) + 1);
              cellRow.push('empty');
            }
            regions.push(regionRow);
            cellStates.push(cellRow);
          }
          
          // Place some stars in the shape (respecting 2x2 constraints)
          const starsToPlace = Math.min(numStars, cells.length);
          for (let i = 0; i < starsToPlace; i++) {
            const cell = cells[i];
            cellStates[cell.row][cell.col] = 'star';
          }
          
          const state = createPuzzleState(size, starsPerUnit, regions, cellStates);
          
          // Compute bounds
          const minStars = computeMinStars(state, cells);
          const maxStars = computeMaxStars(state, cells);
          
          // Property: min should never exceed max
          expect(minStars).toBeLessThanOrEqual(maxStars);
          
          // Property: min should be at least the number of stars already placed
          expect(minStars).toBeGreaterThanOrEqual(starsToPlace);
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property 18: Composite shape hints include all regions
   * Validates: Requirements 10.4
   * 
   * For any hint generated by the composite-shapes technique, the hint's
   * highlights should include all regions that form the composite shape.
   */
  it('Property 18: composite shape hints include all involved regions', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 0, max: 9 }),
        fc.integer({ min: 0, max: 9 }),
        (rowIdx, colIdx) => {
          // Create a puzzle state where composite shapes might apply
          const size = 10;
          const starsPerUnit = 2;
          const regions: number[][] = [];
          const cells: CellState[][] = [];
          
          // Create regions in a 2x5 grid pattern
          for (let r = 0; r < size; r++) {
            const regionRow: number[] = [];
            const cellRow: CellState[] = [];
            for (let c = 0; c < size; c++) {
              regionRow.push(Math.floor(r / 2) * 5 + Math.floor(c / 2) + 1);
              cellRow.push('empty');
            }
            regions.push(regionRow);
            cells.push(cellRow);
          }
          
          const state = createPuzzleState(size, starsPerUnit, regions, cells);
          const hint = findCompositeShapesHint(state);
          
          // If a hint is found, it must have proper highlights
          if (hint) {
            expect(hint.highlights).toBeDefined();
            
            // Must have regions highlighted
            expect(hint.highlights?.regions).toBeDefined();
            expect(hint.highlights?.regions!.length).toBeGreaterThan(0);
            
            // Must have cells highlighted
            expect(hint.highlights?.cells).toBeDefined();
            expect(hint.highlights?.cells!.length).toBeGreaterThan(0);
            
            // Should have either rows or cols (or both) highlighted
            const hasRowOrCol = (hint.highlights?.rows && hint.highlights.rows.length > 0) ||
                               (hint.highlights?.cols && hint.highlights.cols.length > 0);
            expect(hasRowOrCol).toBe(true);
          }
        }
      ),
      { numRuns: 100 }
    );
  });

  it('composite shapes finds forced stars in tight multi-region scenarios', () => {
    // Create a specific scenario where composite shapes applies
    const size = 10;
    const starsPerUnit = 2;
    const regions: number[][] = [];
    const cells: CellState[][] = [];
    
    // Create a region layout where regions 1 and 2 are in the first two columns
    for (let r = 0; r < size; r++) {
      const regionRow: number[] = [];
      const cellRow: CellState[] = [];
      for (let c = 0; c < size; c++) {
        if (c < 2) {
          regionRow.push(1);
        } else if (c < 4) {
          regionRow.push(2);
        } else {
          regionRow.push(c - 1);
        }
        cellRow.push('empty');
      }
      regions.push(regionRow);
      cells.push(cellRow);
    }
    
    // Place stars to create a tight situation
    // Region 1 has 1 star
    cells[0][0] = 'star';
    // Region 2 has 1 star
    cells[0][2] = 'star';
    
    // Row 1 has 1 star already (in region 5)
    cells[1][5] = 'star';
    
    // Mark most cells in row 1 as crosses except for regions 1 and 2
    for (let c = 4; c < size; c++) {
      cells[1][c] = 'cross';
    }
    
    // Mark most cells in regions 1 and 2 as crosses except for row 1
    for (let r = 2; r < size; r++) {
      cells[r][0] = 'cross';
      cells[r][1] = 'cross';
      cells[r][2] = 'cross';
      cells[r][3] = 'cross';
    }
    
    const state = createPuzzleState(size, starsPerUnit, regions, cells);
    const hint = findCompositeShapesHint(state);
    
    // Should find forced moves in the composite shape
    if (hint) {
      expect(hint.technique).toBe('composite-shapes');
      expect(hint.resultCells.length).toBeGreaterThan(0);
      expect(hint.highlights?.regions).toBeDefined();
      expect(hint.highlights?.regions!.length).toBeGreaterThan(1);
    }
  });

  it('composite shapes finds forced crosses when maximum is reached', () => {
    // Create a scenario where overcounting applies to a composite shape
    const size = 10;
    const starsPerUnit = 2;
    const regions: number[][] = [];
    const cells: CellState[][] = [];
    
    // Create regions
    for (let r = 0; r < size; r++) {
      const regionRow: number[] = [];
      const cellRow: CellState[] = [];
      for (let c = 0; c < size; c++) {
        regionRow.push(Math.floor(r / 2) * 5 + Math.floor(c / 2) + 1);
        cellRow.push('empty');
      }
      regions.push(regionRow);
      cells.push(cellRow);
    }
    
    // Place stars to reach maximum in a composite shape
    cells[0][0] = 'star';
    cells[0][2] = 'star';
    
    const state = createPuzzleState(size, starsPerUnit, regions, cells);
    const hint = findCompositeShapesHint(state);
    
    // May or may not find a hint depending on the configuration
    if (hint && hint.kind === 'place-cross') {
      expect(hint.technique).toBe('composite-shapes');
      expect(hint.highlights?.regions).toBeDefined();
    }
  });
});
