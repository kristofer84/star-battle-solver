import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import { findUndercountingHint } from '../src/logic/techniques/undercounting';
import { findCompositeShape, computeMinStars, computeMaxStars } from '../src/logic/helpers';
import type { PuzzleState, PuzzleDef, CellState, Coords } from '../src/types/puzzle';

// Helper to create a puzzle state
function createPuzzleState(size: number, starsPerUnit: number, regions: number[][], cells: CellState[][]): PuzzleState {
  const def: PuzzleDef = { size, starsPerUnit, regions };
  return { def, cells };
}

// Arbitrary generator for valid cell coordinates
const coordsArb = fc.record({
  row: fc.integer({ min: 0, max: 9 }),
  col: fc.integer({ min: 0, max: 9 }),
});

// Generator for a list of unique coordinates
const uniqueCoordsArb = fc.array(coordsArb, { minLength: 1, maxLength: 20 }).map((coords) => {
  const seen = new Set<string>();
  const unique: Coords[] = [];
  for (const coord of coords) {
    const key = `${coord.row},${coord.col}`;
    if (!seen.has(key)) {
      seen.add(key);
      unique.push(coord);
    }
  }
  return unique;
});

describe('Undercounting - Property Tests', () => {
  /**
   * Property 13: Undercounting respects 2×2 constraints
   * Validates: Requirements 7.2
   * 
   * For any composite shape, the computed minimum star count should never
   * exceed the maximum possible stars considering 2×2 block constraints.
   */
  it('Property 13: minimum stars never exceeds maximum stars for any shape', () => {
    fc.assert(
      fc.property(uniqueCoordsArb, (cells) => {
        // Create a simple puzzle state with empty cells
        const size = 10;
        const starsPerUnit = 2;
        const regions: number[][] = [];
        const cellStates: CellState[][] = [];
        
        for (let r = 0; r < size; r++) {
          const regionRow: number[] = [];
          const cellRow: CellState[] = [];
          for (let c = 0; c < size; c++) {
            regionRow.push(Math.floor(r / 2) * 5 + Math.floor(c / 2) + 1);
            cellRow.push('empty');
          }
          regions.push(regionRow);
          cellStates.push(cellRow);
        }
        
        const state = createPuzzleState(size, starsPerUnit, regions, cellStates);
        
        // Compute min and max for the given cells
        const minStars = computeMinStars(state, cells);
        const maxStars = computeMaxStars(state, cells);
        
        // Property: min should never exceed max
        expect(minStars).toBeLessThanOrEqual(maxStars);
      }),
      { numRuns: 100 }
    );
  });

  /**
   * Property 14: Undercounting hints include shape highlights
   * Validates: Requirements 7.4
   * 
   * For any hint generated by the undercounting technique, the hint's
   * highlights should include all regions involved in the composite shape.
   */
  it('Property 14: undercounting hints include region highlights', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 0, max: 9 }),
        fc.integer({ min: 1, max: 10 }),
        (rowIdx, regionId) => {
          // Create a puzzle state where undercounting might apply
          const size = 10;
          const starsPerUnit = 2;
          const regions: number[][] = [];
          const cells: CellState[][] = [];
          
          // Create regions
          for (let r = 0; r < size; r++) {
            const regionRow: number[] = [];
            const cellRow: CellState[] = [];
            for (let c = 0; c < size; c++) {
              // Simple region layout
              regionRow.push(Math.floor(r / 2) * 5 + Math.floor(c / 2) + 1);
              cellRow.push('empty');
            }
            regions.push(regionRow);
            cells.push(cellRow);
          }
          
          const state = createPuzzleState(size, starsPerUnit, regions, cells);
          const hint = findUndercountingHint(state);
          
          // If a hint is found, it must have highlights
          if (hint) {
            expect(hint.highlights).toBeDefined();
            
            // Must have either rows or cols
            const hasRowOrCol = (hint.highlights?.rows && hint.highlights.rows.length > 0) ||
                               (hint.highlights?.cols && hint.highlights.cols.length > 0);
            expect(hasRowOrCol).toBe(true);
            
            // Must have regions
            expect(hint.highlights?.regions).toBeDefined();
            expect(hint.highlights?.regions!.length).toBeGreaterThan(0);
            
            // Must have cells
            expect(hint.highlights?.cells).toBeDefined();
            expect(hint.highlights?.cells!.length).toBeGreaterThan(0);
          }
        }
      ),
      { numRuns: 100 }
    );
  });

  it('undercounting finds forced stars when intersection is tight', () => {
    // Create a specific scenario where undercounting applies
    const size = 10;
    const starsPerUnit = 2;
    const regions: number[][] = [];
    const cells: CellState[][] = [];
    
    // Create a simple region layout
    for (let r = 0; r < size; r++) {
      const regionRow: number[] = [];
      const cellRow: CellState[] = [];
      for (let c = 0; c < size; c++) {
        regionRow.push(c + 1); // Each column is a region
        cellRow.push('empty');
      }
      regions.push(regionRow);
      cells.push(cellRow);
    }
    
    // Place stars to create a tight situation
    // Row 0 has 1 star already
    cells[0][0] = 'star';
    // Region 2 (column 1) has 1 star already
    cells[5][1] = 'star';
    
    // Mark most cells in row 0 as crosses except for column 1
    for (let c = 2; c < size; c++) {
      cells[0][c] = 'cross';
    }
    
    // Mark most cells in region 2 as crosses except for row 0
    for (let r = 1; r < size; r++) {
      if (r !== 5) {
        cells[r][1] = 'cross';
      }
    }
    
    const state = createPuzzleState(size, starsPerUnit, regions, cells);
    const hint = findUndercountingHint(state);
    
    // Should find that cell (0, 1) must be a star
    if (hint) {
      expect(hint.kind).toBe('place-star');
      expect(hint.technique).toBe('undercounting');
      expect(hint.resultCells.length).toBeGreaterThan(0);
    }
  });
});
